/**
 * Code Implementation Generator
 *
 * Generates implementation code for common AWS services
 */
import { ArchitectureAnalysis } from '../types';
import { DocumentationError } from './documentation-error';
import { v4 as uuidv4 } from 'uuid';

export class CodeGenerator {
  /**
   * Generate implementation code from architecture analysis
   */
  async generate(analysisResult: ArchitectureAnalysis): Promise<string> {
    try {
      if (!analysisResult) {
        throw new DocumentationError('No analysis result provided for code generation');
      }

      const code = this.generateAWSImplementationCode(analysisResult);
      return code;
    } catch (error) {
      throw new DocumentationError(
        `Code generation failed: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Generate implementation code using a specific template
   */
  async generateWithTemplate(
    analysisResult: ArchitectureAnalysis,
    template: string,
  ): Promise<string> {
    try {
      if (!analysisResult) {
        throw new DocumentationError(
          'No analysis result provided for template-based code generation',
        );
      }

      // Apply template to the code generation
      const baseCode = this.generateAWSImplementationCode(analysisResult);
      return this.applyTemplate(baseCode, template);
    } catch (error) {
      throw new DocumentationError(
        `Template-based code generation failed: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Generate AWS implementation code based on detected services
   */
  private generateAWSImplementationCode(analysisResult: ArchitectureAnalysis): string {
    const { components, patterns } = analysisResult;
    let code = '';

    // Generate header
    code += `// AWS Architecture Implementation Code
// Generated by AWS Architecture Agent - ${new Date().toISOString()}
// Based on architecture analysis with ${(analysisResult.confidence || 0) * 100}% confidence
\n\n`;

    // Generate imports
    code += `import * as AWS from 'aws-sdk';
// @ts-ignore - UUID module type declaration
const { v4: uuidv4 } = require('uuid');
\n\n`;

    // Generate Lambda functions for detected AWS services
    const awsServices = components.filter((component) => component.isAWSService);

    if (awsServices.length > 0) {
      code += `// AWS Service Implementations
\n`;

      awsServices.forEach((service) => {
        code += this.generateServiceImplementation(service);
      });
    }

    // Generate CloudFormation template
    code += `\n// AWS CloudFormation Template
const cloudFormationTemplate = {
  AWSTemplateFormatVersion: '2010-09-09',
  Description: 'AWS Architecture generated by AWS Architecture Agent',
  Resources: {
`;

    // Add resources based on components
    components.forEach((component) => {
      if (component.isAWSService) {
        code += `    ${this.generateCloudFormationResource(component)},
`;
      }
    });

    code += `  },
  Outputs: {
    ArchitectureID: {
      Description: 'Unique identifier for this architecture',
      Value: { 'Fn::Join': ['-', ['AWS-Architecture', { Ref: 'AWS::StackName' }, '${uuidv4()}']] }
    }
  }
};
\n`;

    // Generate deployment script
    code += `\n// Deployment Script
async function deployArchitecture() {
  try {
    console.log('Deploying AWS Architecture...');

    // Initialize AWS SDK
    AWS.config.update({ region: 'us-east-1' });

    // Create CloudFormation stack
    const cloudFormation = new AWS.CloudFormation();

    const params = {
      StackName: 'aws-architecture-stack-' + uuidv4(),
      TemplateBody: JSON.stringify(cloudFormationTemplate),
      Capabilities: ['CAPABILITY_IAM']
    };

    const result = await cloudFormation.createStack(params).promise();
    console.log('Stack deployment initiated:', result.StackId);

    return result;
  } catch (error) {
    console.error('Deployment failed:', error);
    throw error;
  }
}
\n`;

    // Generate cleanup script
    code += `\n// Cleanup Script
async function cleanupArchitecture(stackName: string) {
  try {
    const cloudFormation = new AWS.CloudFormation();

    console.log('Cleaning up architecture...');
    await cloudFormation.deleteStack({ StackName: stackName }).promise();
    console.log('Architecture cleanup completed');
  } catch (error) {
    console.error('Cleanup failed:', error);
    throw error;
  }
}
\n`;

    // Generate monitoring script
    code += `\n// Monitoring Script
async function monitorArchitecture(stackName: string) {
  try {
    const cloudFormation = new AWS.CloudFormation();

    const result = await cloudFormation.describeStacks({ StackName: stackName }).promise();
    const stack = result.Stacks?.[0];

    if (stack) {
      console.log('Stack Status:', stack.StackStatus);
      console.log('Last Updated:', stack.LastUpdatedTime);
      console.log('Creation Time:', stack.CreationTime);
    }

    return stack;
  } catch (error) {
    console.error('Monitoring failed:', error);
    throw error;
  }
}
\n`;

    // Generate export
    code += `\nexport { deployArchitecture, cleanupArchitecture, monitorArchitecture, cloudFormationTemplate };
`;

    return code;
  }

  /**
   * Generate service-specific implementation
   */
  private generateServiceImplementation(service: any): string {
    const serviceName = service.name.toLowerCase();
    let code = '';

    switch (serviceName) {
      case 'lambda':
        code += `// AWS Lambda Implementation
export const createLambdaFunction = async (functionName: string, handler: string) => {
  const lambda = new AWS.Lambda();

  const params = {
    FunctionName: functionName,
    Runtime: 'nodejs18.x',
    Handler: handler,
    Code: {
      ZipFile: Buffer.from('exports.handler = async (event) => ({ statusCode: 200, body: JSON.stringify({ message: "Hello from Lambda!" }) });')
    },
    Role: 'arn:aws:iam::123456789012:role/lambda-execution-role',
    Environment: {
      Variables: {
        NODE_ENV: 'production'
      }
    }
  };

  try {
    const result = await lambda.createFunction(params).promise();
    console.log('Lambda function created:', result.FunctionArn);
    return result;
  } catch (error) {
    console.error('Lambda creation failed:', error);
    throw error;
  }
};
\n\n`;
        break;

      case 'dynamodb':
        code += `// AWS DynamoDB Implementation
export const createDynamoDBTable = async (tableName: string) => {
  const dynamodb = new AWS.DynamoDB();

  const params = {
    TableName: tableName,
    KeySchema: [
      { AttributeName: 'id', KeyType: 'HASH' }
    ],
    AttributeDefinitions: [
      { AttributeName: 'id', AttributeType: 'S' }
    ],
    ProvisionedThroughput: {
      ReadCapacityUnits: 5,
      WriteCapacityUnits: 5
    }
  };

  try {
    const result = await dynamodb.createTable(params).promise();
    console.log('DynamoDB table created:', result.TableDescription?.TableArn);
    return result;
  } catch (error) {
    console.error('DynamoDB table creation failed:', error);
    throw error;
  }
};
\n\n`;
        break;

      case 's3':
        code += `// AWS S3 Implementation
export const createS3Bucket = async (bucketName: string) => {
  const s3 = new AWS.S3();

  const params = {
    Bucket: bucketName,
    ACL: 'private'
  };

  try {
    const result = await s3.createBucket(params).promise();
    console.log('S3 bucket created:', result.Location);
    return result;
  } catch (error) {
    console.error('S3 bucket creation failed:', error);
    throw error;
  }
};
\n\n`;
        break;

      case 'apigateway':
        code += `// AWS API Gateway Implementation
export const createApiGateway = async (apiName: string) => {
  const apigateway = new AWS.APIGateway();

  const params = {
    name: apiName,
    description: 'API Gateway for AWS Architecture',
    protocolType: 'HTTP'
  };

  try {
    const result = await apigateway.createApi(params).promise();
    console.log('API Gateway created:', result.ApiId);
    return result;
  } catch (error) {
    console.error('API Gateway creation failed:', error);
    throw error;
  }
};
\n\n`;
        break;

      default:
        code += `// ${service.name} Implementation
export const create${service.name.replace(/\s+/g, '')} = async () => {
  // Implementation for ${service.name} would go here
  console.log('${service.name} implementation placeholder');
  return { service: '${service.name}', status: 'placeholder' };
};
\n\n`;
    }

    return code;
  }

  /**
   * Generate CloudFormation resource
   */
  private generateCloudFormationResource(component: any): string {
    const serviceName = component.name.toLowerCase();
    let resource = '';

    switch (serviceName) {
      case 'lambda':
        resource = `LambdaFunction${component.id.replace(/-/g, '')}: {
  Type: 'AWS::Lambda::Function',
  Properties: {
    FunctionName: '${component.name}',
    Runtime: 'nodejs18.x',
    Handler: 'index.handler',
    Code: {
      ZipFile: 'exports.handler = async (event) => ({ statusCode: 200, body: JSON.stringify({ message: "Hello from ${component.name}!" }) });'
    },
    Role: 'arn:aws:iam::123456789012:role/lambda-execution-role',
    Environment: {
      Variables: {
        NODE_ENV: 'production'
      }
    }
  }
}`;
        break;

      case 'dynamodb':
        resource = `DynamoDBTable${component.id.replace(/-/g, '')}: {
  Type: 'AWS::DynamoDB::Table',
  Properties: {
    TableName: '${component.name}',
    KeySchema: [
      { AttributeName: 'id', KeyType: 'HASH' }
    ],
    AttributeDefinitions: [
      { AttributeName: 'id', AttributeType: 'S' }
    ],
    ProvisionedThroughput: {
      ReadCapacityUnits: 5,
      WriteCapacityUnits: 5
    }
  }
}`;
        break;

      case 's3':
        resource = `S3Bucket${component.id.replace(/-/g, '')}: {
  Type: 'AWS::S3::Bucket',
  Properties: {
    BucketName: '${component.name.toLowerCase().replace(/\s+/g, '-')}-${uuidv4()}',
    AccessControl: 'Private'
  }
}`;
        break;

      case 'apigateway':
        resource = `ApiGateway${component.id.replace(/-/g, '')}: {
  Type: 'AWS::ApiGateway::RestApi',
  Properties: {
    Name: '${component.name}',
    Description: 'API Gateway for ${component.name}',
    EndpointConfiguration: {
      Types: ['REGIONAL']
    }
  }
}`;
        break;

      default:
        resource = `${component.name.replace(/\s+/g, '')}Resource: {
  Type: 'AWS::CloudFormation::CustomResource',
  Properties: {
    ServiceToken: { 'Fn::GetAtt': ['LambdaExecutionRole', 'Arn'] },
    ResourceName: '${component.name}',
    Description: 'Custom resource for ${component.name}'
  }
}`;
    }

    return resource;
  }

  /**
   * Apply template to code content
   */
  private applyTemplate(code: string, template: string): string {
    // Simple template application - in a real implementation, this would use a proper templating engine
    return `${template}\n\n// -- Template Applied --\n\n${code}`;
  }
}
